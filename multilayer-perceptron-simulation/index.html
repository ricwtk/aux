<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <link rel="icon" href="icon.png" type="image/x-icon" />
  <title>Multilayer Perceptron Simulation</title>
  <link href="https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/@mdi/font@5.x/css/materialdesignicons.min.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/vuetify@2.x/dist/vuetify.min.css" rel="stylesheet">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui">
  <style>
    html { overflow: auto; }
    .epoch-end { border-bottom-width: 3px!important; border-bottom-color: teal!important; }
  </style>
</head>
<body>
  <div id="app">
    <v-app>
      <v-main>
        <v-sheet width="100%" style="position:sticky;top:0;z-index:100;">
          <v-toolbar color="primary" dark flat>
            <v-toolbar-title>
              Multilayer Perceptron Simulation
            </v-toolbar-title>
            <v-spacer></v-spacer>
            <v-btn icon @click="settings.show = true"><v-icon>mdi-cog</v-icon></v-btn>
          </v-toolbar>
          <v-toolbar color="primary" dark flat>
            <v-col v-for="c in controls" cols="auto" class="mx-2" :key="c.label" :title="c.label">
              <v-row class="justify-center"><v-btn light elevation="2" @click="c.fcn"><v-icon :color="c.color">{{ c.icon }}</v-icon></v-btn></v-row>
            </v-col>
            <v-progress-linear
              :active="display.loading"
              indeterminate
              absolute
              bottom
              color="accent"
            ></v-progress-linear>
            <!-- <v-col class="d-flex align-center">
              <v-slider hide-details="auto" label="Epoch" :min="epochMin" :max="epochMax" thumb-label="always" thumb-color="secondary" v-model="display.epoch"></v-slider>
            </v-col> -->
          </v-toolbar>
        </v-sheet>
        <v-container fluid class="align-content-start py-0">
          <v-card dark color="primary" class="mt-3">
            <v-card-title>Operation: {{ settings.parameters.operation.chosen }}</v-card-title>
            <v-card-text v-show="training.results.content.length > 0">
              <v-subheader class="px-0">Epoch</v-subheader>
              <v-slider :min="epochMin" :max="epochMax" v-model="display.epoch" ticks="always" tick-size="5" thumb-label thumb-color="secondary"></v-slider>
              <v-subheader class="px-0">Data point</v-subheader>
              <v-slider min="1" :max="training.data.length" v-model="display.point" ticks="always" tick-size="5" thumb-label thumb-color="secondary"></v-slider>
              <v-card light flat>
                <svg id="g-neural-network" width="100%" :height="`${graph.neural_network.height}px`" :view-box.camel="graph.neural_network.view_box.join(' ')"></svg>
              </v-card>
              <v-card light flat class="mt-3">
                <svg id="g-decision-regions" width="100%" :height="`${graph.decision_regions.height}px`" :view-box.camel="graph.decision_regions.view_box.join(' ')"></svg>
              </v-card>
            </v-card-text>
          </v-card>
          <v-card dark color="primary" class="mt-3">
            <v-card-title>History</v-card-title>
            <v-card-text v-show="training.results.content.length > 0">
              <v-tabs background-color="transparent" center-active dark v-model="graph.tab">
                <v-tab>Weights</v-tab>
                <v-tab>Thetas</v-tab>
                <v-tab>Error</v-tab>
              </v-tabs>
              <v-tabs-items v-model="graph.tab">
                <v-tab-item eager>
                  <v-card flat>
                    <svg id="g-weights" width="100%" :height="`${graph.height}px`" :view-box.camel="graph.view_box.join(' ')"></svg>
                  </v-card>
                </v-tab-item>
                <v-tab-item eager>
                  <v-card flat>
                    <svg id="g-thetas" width="100%" :height="`${graph.height}px`" :view-box.camel="graph.view_box.join(' ')"></svg>
                  </v-card>
                </v-tab-item>
                <v-tab-item eager>
                  <v-card flat>
                    <svg id="g-error" width="100%" :height="`${graph.height}px`" :view-box.camel="graph.view_box.join(' ')"></svg>
                  </v-card>
                </v-tab-item>
              </v-tabs-items>
            </v-card-text>
          </v-card>
          <v-card dark class="mt-3 mb-3" color="primary">
            <v-card-title>Table</v-card-title>
            <v-card-text background-color="primary">
              <v-simple-table>
                <template v-slot:default>
                  <thead>
                    <tr v-if="training.results.content.length > 0">
                      <th class="text-center epoch-end">Epoch</th>
                      <th v-for="col,i in training.results.header" :key="`tableheader-${i}`" class="text-center epoch-end">{{ col }}</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr v-for="row,i in training.results.content">
                      <td class="text-center" :class=" i % training.data.length == training.data.length - 1 ? 'epoch-end' : '' ">{{ i % training.data.length == 0 ? i/training.data.length + 1 : "" }}</td>
                      <td class="text-center" v-for="col,j in row" :key="`tableitem-${i}-${j}`" :class=" i % training.data.length == training.data.length - 1 ? 'epoch-end' : '' ">{{ j > 2 ? Number(col).toFixed(4) : col }}</td>
                    </tr>
                  </tbody>
                </template>
              </v-simple-table>
            </v-card-text>
          </v-card>

          <v-overlay :value="display.loading">
          </v-overlay>
          
          <v-dialog v-model="settings.show" scrollable>
            <v-card>
              <v-card-title>Parameter values</v-card-title>
              <v-divider></v-divider>
              <v-card-text>
                <v-list rounded>
                  <v-list-item>
                    <v-select label="Operation to model/learn" :items="settings.parameters.operation.options" v-model="settings.parameters.operation.chosen" hide-details></v-select>
                  </v-list-item>
                  <v-subheader>Neuron Number in Layers</v-subheader>
                  <v-list-item v-for="l,li in settings.parameters.neuron_n" :key="`neuron-n-${li}`">
                    <v-text-field :label="li == 0 ? 'Input layer' : li == settings.parameters.neuron_n.length - 1 ? 'Output layer' : `Hidden layer ${li}`" v-model="settings.parameters.neuron_n[li]" hide-details :readonly="li == 0 || li == settings.parameters.neuron_n.length-1"></v-text-field>
                  </v-list-item>
                  <v-subheader>Activation Functions</v-subheader>
                  <v-list-item v-for="actfcn,ai in settings.parameters.activation_fcns" :key="`actfcn-${ai}`">
                    <v-select :label="ai == settings.parameters.activation_fcns.length - 1 ? 'Output layer' : `Hidden layer ${ai+1}`" v-model="settings.parameters.activation_fcns[ai]" :items="Object.keys(activation_fcns)" hide-details></v-text-field>
                  </v-list-item>
                  <v-subheader>Weights</v-subheader>
                  <template v-for="l,li in settings.parameters.weights">
                    <template v-for="n,ni in l">
                      <v-list-item v-for="w,wi in n" :key="`weight-${neuronNames[li][wi]}-${neuronNames[li+1][ni]}`">
                        <v-text-field :label="`w${neuronNames[li][wi]}${neuronNames[li+1][ni]}`" v-model="settings.parameters.weights[li][ni][wi]" hide-details></v-text-field>
                      </v-list-item>
                    </template>
                  </template>
                  <v-subheader>Thresholds</v-subheader>
                  <template v-for="l,li in settings.parameters.thetas">
                    <v-list-item v-for="n,ni in l" :key="`theta-${neuronNames[li+1][ni]}`">
                      <v-text-field :label="`Θ${neuronNames[li+1][ni]}`" v-model="settings.parameters.thetas[li][ni]" hide-details></v-text-field>
                    </v-list-item>
                  </template>
                  <v-subheader>Learning rate</v-subheader>
                  <v-list-item>
                    <v-text-field label="α" v-model="settings.parameters.alpha" hide-details></v-text-field>
                  </v-list-item>
                </v-list>
              </v-card-text>
              <v-divider></v-divider>
              <v-card-actions>
                <span class="subtitle-2"><b>Note</b>: no termination condition is implemented</span>
                <v-spacer></v-spacer>
                <v-btn color="primary" @click="setConfigurations">Set</v-btn>
                <v-btn @click="settings.show=false">Cancel</v-btn>
              </v-card-actions>
            </v-card>
          </v-dialog>

          <div id="gdrtt" style="opacity:0;position:absolute;background-color:rgba(255,255,255,0.5);padding:5px 10px;border-radius:5px"></div>
          <div id="gnntt" style="opacity:0;position:absolute;background-color:rgba(255,255,255,0.5);padding:5px 10px;border-radius:5px"></div>
        </v-container>
      </v-main>
    </v-app>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/vue@2.x/dist/vue.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vuetify@2.x/dist/vuetify.js"></script>
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <script src="https://d3js.org/d3-scale-chromatic.v0.3.min.js"></script>
  <script>
    let defaults = {
      nn: {
        neuron_n: [2, 2, 1],
        activation_fcns: ["sigmoid", "sigmoid"]
      }
    };
    let vm = new Vue({
      el: '#app',
      vuetify: new Vuetify({
        theme: {
          themes: {
            light: {
              primary: "#009688",
              secondary: "#80CBC4",
              accent: "#1DE9B6",
              highlight: "#D32F2F"
            }
          }
        }
      }),
      data: {
        controls: [{
          icon: "mdi-play",
          label: "Run 1 epoch",
          color: "primary",
          fcn: function () { vm.runEpoch(); }
        },{
          icon: "mdi-skip-next",
          label: "Run 10 epoch",
          color: "secondary",
          fcn: function () { vm.runEpoch(10); }
        },{
          icon: "mdi-skip-forward",
          label: "Run 50 epoch",
          color: "secondary",
          fcn: function () { vm.runEpoch(50); }
        },{
          icon: "mdi-undo-variant",
          label: "reset",
          color: "secondary",
          fcn: function () { vm.resetLearning(); }
        },{
          icon: "mdi-autorenew",
          label: "randomise",
          color: "secondary",
          fcn: function () { vm.randomise(); }
        }],
        settings: {
          show: false,
          parameters: {
            operation: {
              chosen: "AND",
              options: ["AND", "OR", "is-x1", "is-x2", "Exclusive-OR", "Exclusive-AND"],
              data: [[ //AND
                [0, 0, 0],
                [0, 1, 0],
                [1, 0, 0],
                [1, 1, 1]
              ],[ //OR
                [0, 0, 0],
                [0, 1, 1],
                [1, 0, 1],
                [1, 1, 1]
              // ],[ //NAND
              //   [0, 0, 1],
              //   [0, 1, 1],
              //   [1, 0, 1],
              //   [1, 1, 0]
              // ],[ //NOR
              //   [0, 0, 1],
              //   [0, 1, 0],
              //   [1, 0, 0],
              //   [1, 1, 0]
              ],[ //is-x1
                [0, 0, 0],
                [0, 1, 0],
                [1, 0, 1],
                [1, 1, 1]
              ],[ //is-x2
                [0, 0, 0],
                [0, 1, 1],
                [1, 0, 0],
                [1, 1, 1]
              ],[ //XOR
                [0, 0, 0],
                [0, 1, 1],
                [1, 0, 1],
                [1, 1, 0]
              ],[ //XAND
                [0, 0, 1],
                [0, 1, 0],
                [1, 0, 0],
                [1, 1, 1]
              ]]
            },
            neuron_n: [],
            weights: [],
            thetas: [],
            alpha: 0.5,
            activation_fcns: [],
            cached: {
              operation: "",
              neuron_n: [],
              activation_fcns: [],
              weights: [],
              thetas: [],
              alpha: 0
            }
          }
        },
        training: {
          weights: [],
          thetas: [],
          data: [],
          labels: ['x1', 'x2', 'y'],
          inputs: [0, 1],
          output: 2,
          current_data_idx: 0,
          results: {
            header: [],
            content: []
          }
        },
        display: {
          epoch: 1,
          point: 1,
          loading: false
        },
        graph: {
          tab: 0,
          height: 500,
          view_box: [0,0,1000,500],
          margin: {
            left: 50,
            bottom: 50,
            right: 50,
            top: 25
          },
          neural_network: {
            view_box: [0,0,1000,300],
            height: 300,
            margin: {
              left: 50,
              bottom: 50,
              right: 50,
              top: 50
            }
          },
          decision_regions: {
            view_box: [0,0,1000,500],
            height: 500,
            margin: {
              left: 50,
              bottom: 50,
              right: 120,
              top: 25
            },
            x: {
              min: -1,
              max: 2,
              count: 20
            },
            y: {
              min: -1,
              max: 2,
              count: 20
            }
          },
          analysis: {
            colors: [
              "#66c2a5",
              "#fc8d62",
              "#8da0cb"
            ]
          }
        },
        activation_fcns: {
          sigmoid: (X) => 1/(1+Math.exp(-X)),
          step: (X,low_y=0,high_y=1) => Math.min(high_y, Math.max(low_y, Math.ceil(X)))
        }
      },
      created: function () {
        this.settings.parameters.neuron_n = [...defaults.nn.neuron_n];
        this.settings.parameters.activation_fcns = [...defaults.nn.activation_fcns];
        this.randomise();
      },
      computed: {
        epochMin: function () {
          return Math.min(this.epochMax, 1);
        },
        epochMax: function () {
          return Math.ceil(this.training.results.content.length / this.training.data.length);
        },
        neuronNames: function () {
          let neuron_names = [];
          let curr_neuron_name = 1;
          this.settings.parameters.neuron_n.forEach(n => {
            neuron_names.push([...Array(n).keys()].map(i => curr_neuron_name + i));
            curr_neuron_name += n;
          });
          return neuron_names;
        },
        numberOfWeights: function () { 
          return [...Array(this.settings.parameters.neuron_n.length-1).keys()].reduce((acc,n) => acc + this.settings.parameters.neuron_n[n]*this.settings.parameters.neuron_n[n+1], 0); 
        },
        numberOfThetas: function () {
          return this.settings.parameters.neuron_n.slice(1).reduce((acc,n) => acc + n, 0);
        },
      },
      watch: {
        "training.results.content": function () {
          this.display.loading = true;
          this.drawNeuralNetworkGraph();
          this.drawDecisionRegionsGraph();
          this.drawWeightGraph();
          this.drawThetaGraph();
          this.drawErrorGraph();
          setTimeout(() => this.display.loading = false, 1000);
        },
        "display.epoch": function () {
          this.display.loading = true;
          this.drawNeuralNetworkGraph();
          this.drawDecisionRegionsGraph();
          setTimeout(() => this.display.loading = false, 1000);

        },
        "display.point": function () {
          this.display.loading = true;
          this.drawNeuralNetworkGraph();
          this.drawDecisionRegionsGraph();
          setTimeout(() => this.display.loading = false, 1000);
        },
        "settings.show": function (showing) {
          if (showing) {
            this.settings.parameters.cached = {
              operation: this.settings.parameters.operation.chosen,
              neuron_n: this.settings.parameters.neuron_n.map(layer => layer),
              activation_fcns: this.settings.parameters.activation_fcns.map(layer => layer),
              weights: this.settings.parameters.weights.map(layer => layer.map(neuron => neuron.map(weight => weight))),
              thetas: this.settings.parameters.thetas.map(layer => layer.map(neuron => neuron)),
              alpha: this.settings.parameters.alpha
            };
          } else {
            this.settings.parameters.operation.chosen = this.settings.parameters.cached.operation;
            this.settings.parameters.neuron_n = this.settings.parameters.cached.neuron_n.map(layer => layer);
            this.settings.parameters.activation_fcns = this.settings.parameters.cached.activation_fcns.map(layer => layer);
            this.settings.parameters.weights = this.settings.parameters.cached.weights.map(layer => layer.map(neuron => neuron.map(weight => weight)));
            this.settings.parameters.thetas = this.settings.parameters.cached.thetas.map(layer => layer.map(neuron => neuron));
            this.settings.parameters.alpha = this.settings.parameters.cached.alpha;
          }
        }
      },
      methods: {
        runIter: function (n=1) {
          if (this.training.results.header.length == 0) { 
            this.neuronNames[0].forEach((neuron_name,n) => {
              if (this.neuronNames[0].length == 1) {
                this.training.results.header.push("x");
              } else {
                this.training.results.header.push(`x${neuron_name}`);
              }
            });
            this.neuronNames[this.neuronNames.length-1].forEach((neuron_name,n) => {
              if (this.neuronNames[this.neuronNames.length-1].length == 1) {
                this.training.results.header.push("expected y");
              } else {
                this.training.results.header.push(`expected y${neuron_name}`);
              }
            });
            this.training.weights.forEach((layer,l) => {
              layer.forEach((neuron,n) => {
                neuron.forEach((weight,w) => {
                  this.training.results.header.push(`w${this.neuronNames[l][w]}${this.neuronNames[l+1][n]}`)
                });
              });
            });
            this.training.thetas.forEach((layer,l) => {
              layer.forEach((neuron,n) => {
                this.training.results.header.push(`Θ${this.neuronNames[l+1][n]}`)
              });
            });
            this.neuronNames.slice(1).forEach(layer => {
              layer.forEach(neuron_name => {
                this.training.results.header.push(`y${neuron_name}`);
              });
            });
            this.neuronNames[this.neuronNames.length-1].forEach((neuron_name,n) => {
              if (this.neuronNames[this.neuronNames.length-1].length == 1) {
                this.training.results.header.push("error");
              } else {
                this.training.results.header.push(`error ${neuron_name}`);
              }
            });
            this.neuronNames.slice(1).forEach(layer => {
              layer.forEach(neuron_name => {
                if ((this.neuronNames.length < 3) && (layer.length  == 1)) {
                  this.training.results.header.push("δ");
                } else {
                  this.training.results.header.push(`δ${neuron_name}`);
                }
              });
            });
            this.training.weights.forEach((layer,l) => {
              layer.forEach((neuron,n) => {
                neuron.forEach((weight,w) => {
                  this.training.results.header.push(`Δw${this.neuronNames[l][w]}${this.neuronNames[l+1][n]}`)
                });
              });
            });
            this.training.thetas.forEach((layer,l) => {
              layer.forEach((neuron,n) => {
                this.training.results.header.push(`ΔΘ${this.neuronNames[l+1][n]}`)
              });
            });
            this.training.weights.forEach((layer,l) => {
              layer.forEach((neuron,n) => {
                neuron.forEach((weight,w) => {
                  this.training.results.header.push(`w${this.neuronNames[l][w]}${this.neuronNames[l+1][n]}'`)
                });
              });
            });
            this.training.thetas.forEach((layer,l) => {
              layer.forEach((neuron,n) => {
                this.training.results.header.push(`Θ${this.neuronNames[l+1][n]}'`)
              });
            });
          }
          [...Array(n).keys()].forEach(() => {
            let res = [];
            dt = this.training.data[this.training.current_data_idx]
            
            res.push(...dt.slice(0,this.settings.parameters.neuron_n[0]));
            res.push(...dt.slice(this.settings.parameters.neuron_n[0], this.settings.parameters.neuron_n[0]+this.settings.parameters.neuron_n[this.settings.parameters.neuron_n.length-1]));
            this.training.weights.forEach(layer => {
              layer.forEach(neuron => {
                neuron.forEach(weight => {
                  res.push(weight);
                });
              });
            });
            this.training.thetas.forEach(layer => {
              layer.forEach(theta => {
                res.push(theta);
              });
            })

            let outputs = this.calcOutput(dt.slice(0,this.settings.parameters.neuron_n[0]), this.training.weights, this.training.thetas, this.settings.parameters.activation_fcns);

            outputs.slice(1).forEach(layer => {
              layer.forEach(output => {
                res.push(output);
              });
            });

            let errAndErrGrad = this.calcErrorGradients(
              dt.slice(this.settings.parameters.neuron_n[0],this.settings.parameters.neuron_n[0]+this.settings.parameters.neuron_n[this.settings.parameters.neuron_n.length-1]),
              outputs,
              this.training.weights
            );

            errAndErrGrad[0][errAndErrGrad[0].length-1].forEach(err => { res.push(err); });
            errAndErrGrad[1].forEach(layer => { layer.forEach(errGrad => { res.push(errGrad); }); });

            let weightCorrections = this.calcWeightCorrections(outputs, errAndErrGrad[1], this.training.weights);

            weightCorrections.forEach(layer => {
              layer.forEach(neuron => {
                neuron.forEach(wcorr => {
                  res.push(wcorr);
                });
              });
            });

            let thetaCorrections = this.calcThetaCorrections(errAndErrGrad[1]);

            thetaCorrections.forEach(layer => {
              layer.forEach(tcorr => {
                res.push(tcorr);
              });
            });
            
            this.training.weights = this.calcNewWeights(this.training.weights, weightCorrections);
            this.training.thetas = this.calcNewThetas(this.training.thetas, thetaCorrections);

            this.training.weights.forEach(layer => {
              layer.forEach(neuron => {
                neuron.forEach(weight => {
                  res.push(weight);
                });
              });
            });
            this.training.thetas.forEach(layer => {
              layer.forEach(theta => {
                res.push(theta);
              });
            })
            
            this.training.current_data_idx = ( this.training.current_data_idx + 1 )% this.training.data.length;
            this.training.results.content.push(res);
          });
          this.display.epoch = this.epochMax;
        },
        runEpoch: function (n=1) {
          this.display.loading = true;
          setTimeout(() => {
            [...Array(n).keys()].forEach(() => {
              this.runIter(this.training.data.length - this.training.current_data_idx);
            });
          }, 500);
          // this.display.loading = false;
        },
        calcOutput: function (inputs, weights, thetas, actfcns) {
          let ys = [[...inputs]];
          weights.forEach((layer,l) => {
            ys.push([]);
            layer.forEach((weight,w) => {
              ys[ys.length-1].push(this.activateNeuron(ys[ys.length-2], weight, thetas[l][w], this.activation_fcns[actfcns[l]]));
            })
          });
          return ys;
        },
        activateNeuron: function (inputs, weights, theta, actfcn) {
          return actfcn(inputs.map((ip,i) => ip * weights[i]).reduce((acc,v) => acc + v, 0) - theta);
        },
        calcErrorGradients: function (expecteds, outputs, weights) {
          let err = [expecteds.map((ex,i) => ex - outputs[outputs.length-1][i])];
          let egrad = [];
          [...Array(weights.length).keys()].map(x => weights.length - x - 1).forEach(layer_i => {
            egrad.unshift([...Array(weights[layer_i].length).keys()].map( neuron_i => outputs[layer_i+1][neuron_i] * (1 - outputs[layer_i+1][neuron_i]) * err[0][neuron_i] ));
            if (layer_i > 0) { 
              err.unshift(weights[layer_i - 1].map((beforelayer_weights,beforelayer_neuron_i) => weights[layer_i].map((neuron_weights,neuron_i) => neuron_weights[beforelayer_neuron_i]*egrad[0][neuron_i]).reduce((acc,val) => acc+val,0)));
            }
          });
          return [err,egrad];
        },
        calcWeightCorrections: function (outputs, egradients, weights) {
          return weights.map((layer,l) => 
            layer.map((neuron,n) => 
              neuron.map((conn,c) => 
                this.settings.parameters.alpha * outputs[l][c] * egradients[l][n]
              )
            )
          );
        },
        calcNewWeights: function (weights, wcorrections) {
          return weights.map((layer,l) => 
            layer.map((neuron,n) => 
              neuron.map((conn,c) => 
                conn + wcorrections[l][n][c]
              )
            )
          );
        },
        calcThetaCorrections: function (egradients) {
          return egradients.map(layer => layer.map(egrad => this.settings.parameters.alpha * -1 * egrad));
        },
        calcNewThetas: function (thetas, tcorrections) {
          return thetas.map((layer,l) => 
            layer.map((theta,t) => 
              theta + tcorrections[l][t]
            )
          );
        },
        setConfigurations: function () {
          this.settings.parameters.cached = {
            operation: this.settings.parameters.operation.chosen,
            neuron_n: this.settings.parameters.neuron_n.map(layer => Number(layer)),
            activation_fcns: this.settings.parameters.activation_fcns.map(layer => layer),
            weights: this.settings.parameters.weights.map(layer => layer.map(neuron => neuron.map(weight => Number(weight)))),
            thetas: this.settings.parameters.thetas.map(layer => layer.map(neuron => Number(neuron))),
            alpha: Number(this.settings.parameters.alpha)
          };
          this.settings.show = false;
          this.$nextTick().then(this.resetLearning);
        },
        resetLearning: function () {
          this.training.weights = this.settings.parameters.weights.map(layer => layer.map(neuron => neuron.map(weight => weight)));
          this.training.thetas = this.settings.parameters.thetas.map(layer => layer.map(neuron => neuron));
          this.training.data = this.settings.parameters.operation.data[this.settings.parameters.operation.options.indexOf(this.settings.parameters.operation.chosen)].map(x => [...x]);
          this.training.results = {
            header: [],
            content: []
          };
        },
        randomise: function () {
          this.settings.parameters.weights = this.settings.parameters.neuron_n.slice(1).map((n,i) => {
            return [...Array(n)].map(x => {
              return [...Array(this.settings.parameters.neuron_n[i])].map(x => Math.random() - 0.5);
            });
          });
          this.settings.parameters.thetas = this.settings.parameters.neuron_n.slice(1).map((n,i) => {
            return [...Array(n)].map(x => Math.random() - 0.5);
          });
          this.resetLearning();
        },
        drawNeuralNetworkGraph: function () {
          let gnn = d3.select("#g-neural-network");
          gnn.selectAll("*").remove();
          let showing_iter = Math.min((this.display.epoch - 1) * this.training.data.length + this.display.point, this.training.results.content.length - 1);
          if (showing_iter < 0) { return; }
          
          let inputs = this.training.results.content[showing_iter].slice(0,this.settings.parameters.neuron_n[0]);
          let output = this.training.results.content[showing_iter].slice(this.settings.parameters.neuron_n[0], this.settings.parameters.neuron_n[0]+this.settings.parameters.neuron_n[this.settings.parameters.neuron_n.length-1]);
          let aftercalcoutputindex = this.settings.parameters.neuron_n[0] + this.settings.parameters.neuron_n[this.settings.parameters.neuron_n.length-1] + this.numberOfWeights + this.numberOfThetas + this.numberOfThetas;
          let calculatedoutput = this.training.results.content[showing_iter].slice(aftercalcoutputindex-output.length, aftercalcoutputindex);
          let startindex = this.settings.parameters.neuron_n[0] + this.settings.parameters.neuron_n[this.settings.parameters.neuron_n.length-1];
          let weights = this.training.results.content[showing_iter].slice(startindex,startindex+this.numberOfWeights);
          weights = this.settings.parameters.neuron_n.slice(1).reduce((acc,n,i) => {
            let layer = [];
            [...Array(n)].forEach(() => {
              let neuron = [];
              [...Array(this.settings.parameters.neuron_n[i])].forEach(() => {
                neuron.push(weights.shift());
              });
              layer.push(neuron);
            });
            acc.push(layer);
            return acc;
          }, []);
          let thetas = this.training.results.content[showing_iter].slice(startindex+this.numberOfWeights,startindex+this.numberOfWeights+this.numberOfThetas);
          thetas = this.settings.parameters.neuron_n.slice(1).reduce((acc,n) => {
            let layer = [];
            [...Array(n)].forEach(() => {
              layer.push(thetas.shift());
            });
            acc.push(layer);
            return acc;
          }, []);

          let neuron_scale = this.settings.parameters.neuron_n.map(n => {
            return d3.scaleLinear()
              .domain([0.5, n+0.5])
              .range([this.graph.neural_network.view_box[1]+this.graph.neural_network.view_box[3]-this.graph.neural_network.margin.bottom, this.graph.neural_network.view_box[1]+this.graph.neural_network.margin.top]);
          });
          let layer_scale = d3.scaleLinear()
            .domain([-0.5, this.settings.parameters.neuron_n.length-0.5])
            .range([this.graph.neural_network.view_box[0]+this.graph.neural_network.margin.left, this.graph.neural_network.view_box[0]+this.graph.neural_network.view_box[2]-this.graph.neural_network.margin.right]);
          neuron_scale.map((scale,i) => {
            if (i == 0) {
              let idata = gnn.selectAll()
                .data([...Array(Math.floor(scale.domain()[1])).keys()].map(x => x+1));
              idata.enter()
                .append("line")
                .attr("x1", layer_scale(i-0.5))
                .attr("x2", layer_scale(i))
                .attr("y1", d => scale(d))
                .attr("y2", d => scale(d))
                .attr("stroke", this.$vuetify.theme.themes.light.primary);
              idata.enter()
                .append("text")
                .attr("x", layer_scale(i-0.5))
                .attr("y", d => scale(d))
                .attr("dominant-baseline", "middle")
                .attr("text-anchor", "end")
                .attr("fill", this.$vuetify.theme.themes.light.primary)
                .text(d => `x${Math.floor(scale.domain()[1]) - d + 1} (${inputs[Math.floor(scale.domain()[1]) - d]}) `);
            }
            if (i < neuron_scale.length - 1) {
              gnn.selectAll()
                .data([...Array(Math.floor(scale.domain()[1])).keys()].reduce((conn,connin) => {
                  conn.push(...[...Array(Math.floor(neuron_scale[i+1].domain()[1])).keys()].reduce((conn,connout) => {
                    conn.push([connin+1, connout+1]);
                    return conn;
                  }, conn));
                  return conn;
                }, []))
                .enter()
                  .append("line")
                  .attr("x1", layer_scale(i))
                  .attr("x2", layer_scale(i+1))
                  .attr("y1", d => scale(d[0]))
                  .attr("y2", d => neuron_scale[i+1](d[1]))
                  .attr("stroke", this.$vuetify.theme.themes.light.primary);
            }
            if (i == neuron_scale.length - 1) {
              let odata = gnn.selectAll()
                .data([...Array(Math.floor(scale.domain()[1])).keys()].map(x => x+1));
              odata.enter()
                .append("line")
                .attr("x1", layer_scale(i+0.5))
                .attr("x2", layer_scale(i))
                .attr("y1", d => scale(d))
                .attr("y2", d => scale(d))
                .attr("stroke", this.$vuetify.theme.themes.light.primary);
              odata.enter()
                .append("text")
                .attr("x", layer_scale(i+0.5))
                .attr("y", d => scale(d))
                .attr("dominant-baseline", "middle")
                .attr("text-anchor", "start")
                .attr("fill", this.$vuetify.theme.themes.light.primary)
                .text(d => (Math.floor(scale.domain()[1]) == 1 ? "Y" : `Y${Math.floor(scale.domain()[1]) - d + 1}`) + ` (${output[Math.floor(scale.domain()[1]) - d]} | ${calculatedoutput[Math.floor(scale.domain()[1]) - d].toFixed(3)}) `)
                .on("mousemove", (event,d) => {
                  d3.select("#gnntt")
                    .style("opacity", 0.9)
                    .style("left", `${event.pageX+20}px`)
                    .style("top", `${event.pageY}px`)
                    .html(`Expected: ${output[Math.floor(scale.domain()[1]) - d]}<br>Calculated: ${calculatedoutput[Math.floor(scale.domain()[1]) - d].toFixed(3)}`);
                })
                .on("mouseleave", () => {
                  d3.select("#gnntt")
                    .style("opacity",0)
                    .style("left", "0px")
                    .style("top", "0px");
                });
            }
          });
          let radius = Math.min(...neuron_scale.reduce((acc, scale) => {
            acc.push(scale(1)-scale(1.3));
            return acc;
          }, []));
          let neuron_n_prev = 0;
          neuron_scale.map((scale,i) => {
            let ndata = gnn.selectAll()
              .data([...Array(Math.floor(scale.domain()[1])).keys()].map(x => x+1));
            ndata.enter()
              .append("circle")
              .attr("cx", layer_scale(i))
              .attr("cy", d => scale(d))
              .attr("r", radius)
              .attr("fill", this.$vuetify.theme.themes.light.secondary);
            ndata.enter()
              .append("text")
              .attr("x", layer_scale(i))
              .attr("y", d => scale(d))
              .attr("fill", this.$vuetify.theme.themes.light.primary)
              .attr("dominant-baseline", "middle")
              .attr("text-anchor", "middle")
              .style("font-size", `${1.1*radius}px`)
              .text(d => neuron_n_prev + Math.floor(scale.domain()[1]) - d + 1);
            ndata.enter()
              .append("circle")
              .attr("cx", layer_scale(i))
              .attr("cy", d => scale(d))
              .attr("r", radius)
              .attr("fill-opacity", 0)
              .attr("stroke", this.$vuetify.theme.themes.light.primary)
              .attr("stroke-width", 0.1*radius)
              .on("mousemove", (event,d) => {
                if (i > 0) {
                  d3.select("#gnntt")
                    .style("opacity", 0.9)
                    .style("left", `${event.pageX+20}px`)
                    .style("top", `${event.pageY}px`)
                    .html(`${weights[i-1][weights[i-1].length-d].map((w,pi) => `w<sub>${this.neuronNames[i-1][pi]}${this.neuronNames[i][this.neuronNames[i].length-d]}</sub>: ${w.toFixed(2)}`).join("<br>")}<br>Θ<sub>${this.neuronNames[i][this.neuronNames[i].length-d]}</sub>: ${thetas[i-1][thetas[i-1].length-d].toFixed(2)}`);
                  d3.select(event.target)
                    .attr("stroke", this.$vuetify.theme.themes.light.highlight);
                }
              })
              .on("mouseleave", () => {
                d3.select("#gnntt")
                  .style("opacity",0)
                  .style("left", "0px")
                  .style("top", "0px");
                d3.select(event.target)
                  .attr("stroke", this.$vuetify.theme.themes.light.primary);
              });
            neuron_n_prev += Math.floor(scale.domain()[1]);
          });
        },
        drawWeightGraph: function () {
          let gw = d3.select("#g-weights");
          gw.selectAll("*").remove();
          if (this.training.results.content.length == 0) { return; }
          let startindex = this.settings.parameters.neuron_n[0]+this.settings.parameters.neuron_n[this.settings.parameters.neuron_n.length-1];
          
          let data = this.training.results.content.map((d,i) => ({
            x: i+1,
            y: d.slice(
              startindex,
              startindex + this.numberOfWeights
            )
          }));
          let scale = {
            x: d3.scaleLinear()
              .domain([Math.min(...data.map(d => d.x)), Math.max(...data.map(d => d.x))])
              .range([this.graph.margin.left, this.graph.view_box[2] + this.graph.view_box[0] - this.graph.margin.right]),
            y: d3.scaleLinear()
              .domain([Math.min(...data.reduce((acc,d) => { acc.push(...d.y); return acc; }, [])), Math.max(...data.reduce((acc,d) => { acc.push(...d.y); return acc; }, []))])
              .range([this.graph.view_box[3] + this.graph.view_box[1] - this.graph.margin.bottom, this.graph.view_box[1] + this.graph.margin.top]),
          };
          let xtickValues = scale.x.ticks().filter(Number.isInteger);
          let axes = {
            x: d3.axisBottom(scale.x).tickValues(xtickValues).tickFormat(d3.format('d')),
            y: d3.axisLeft(scale.y)
          };

          gw.append("g")
            .attr("transform", `translate(0,${this.graph.view_box[3]+this.graph.view_box[1]-this.graph.margin.bottom})`)
            .call(axes.x);
          gw.append("g")
            .attr("transform", `translate(${this.graph.view_box[0]+this.graph.margin.left},0)`)
            .call(axes.y);
          [...Array(this.numberOfWeights).keys()].forEach(i => {
            gw.append("path")
              .datum(data)
              .attr("fill", "none")
              .attr("stroke", this.graph.analysis.colors[i%this.graph.analysis.colors.length])
              .attr("stroke-width", 5)
              .attr("stroke-linejoin", "round")
              .attr("stroke-linecap", "round")
              .attr("d", d3.line().x(d => scale.x(d.x)).y(d => scale.y(d.y[i])));
            // gw.selectAll()
            //   .data(data)
            //   .enter().append("circle")
            //   .attr("cx", d => scale.x(d.x))
            //   .attr("cy", d => scale.y(d.y[i]))
            //   .attr("r", 8)
            //   .attr("fill", this.graph.analysis.colors[i%this.graph.analysis.colors.length])
            //   .attr("stroke", "white")
            //   .attr("stroke-width", 0);
          });

          let weightnames = this.training.results.header.slice(startindex, startindex+this.numberOfWeights);
          [...Array(this.numberOfWeights).keys()].forEach(i => {
            gw.append("text")
              .attr("x", scale.x(data[data.length-1].x)+10)
              .attr("y", scale.y(data[data.length-1].y[i]))
              .attr("text-anchor", "start")
              .attr("dominant-baseline", "middle")
              .attr("stroke-width", 3.5)
              .attr("stroke", this.graph.analysis.colors[i%this.graph.analysis.colors.length])
              .text(weightnames[i]);
            gw.append("text")
              .attr("x", scale.x(data[data.length-1].x)+10)
              .attr("y", scale.y(data[data.length-1].y[i]))
              .attr("text-anchor", "start")
              .attr("dominant-baseline", "middle")  
              .style("fill", "white")
              .text(weightnames[i]);
          });
          gw.append("text")
            .attr("x", (scale.x.range()[1] + scale.x.range()[0])/2)
            .attr("y", this.graph.view_box[1] + this.graph.view_box[3] - 10)
            .attr("text-anchor", "middle")
            .attr("dominant-baseline", "text-bottom")
            .text("Iteration")
          let labelpos = {
            x: this.graph.view_box[0],
            y: (scale.y.range()[1] + scale.y.range()[0])/2
          }
          gw.append("text")
            .attr("x", labelpos.x)
            .attr("y", labelpos.y)
            .attr("transform", `rotate(-90,${labelpos.x},${labelpos.y})`)
            .attr("text-anchor", "middle")
            .attr("dominant-baseline", "middle")
            .text("Weights");
        },
        drawThetaGraph: function () {
          let gt = d3.select("#g-thetas");
          gt.selectAll("*").remove();
          if (this.training.results.content.length == 0) { return; }

          let startindex = this.settings.parameters.neuron_n[0]+this.settings.parameters.neuron_n[this.settings.parameters.neuron_n.length-1]+this.numberOfWeights;

          let data = this.training.results.content.map((d,i) => ({
            x: i+1,
            y: d.slice(
              startindex,
              startindex + this.numberOfThetas
            )
          }));
          let scale = {
            x: d3.scaleLinear()
              .domain([Math.min(...data.map(d => d.x)), Math.max(...data.map(d => d.x))])
              .range([this.graph.margin.left, this.graph.view_box[2] + this.graph.view_box[0] - this.graph.margin.right]),
            y: d3.scaleLinear()
              .domain([Math.min(...data.reduce((acc,d) => { acc.push(...d.y); return acc; }, [])), Math.max(...data.reduce((acc,d) => { acc.push(...d.y); return acc; }, []))])
              .range([this.graph.view_box[3] + this.graph.view_box[1] - this.graph.margin.bottom, this.graph.view_box[1] + this.graph.margin.top]),
          };
          let xtickValues = scale.x.ticks().filter(Number.isInteger);
          let axes = {
            x: d3.axisBottom(scale.x).tickValues(xtickValues).tickFormat(d3.format('d')),
            y: d3.axisLeft(scale.y)
          };

          gt.append("g")
            .attr("transform", `translate(0,${this.graph.view_box[3]+this.graph.view_box[1]-this.graph.margin.bottom})`)
            .call(axes.x);
          gt.append("g")
            .attr("transform", `translate(${this.graph.view_box[0]+this.graph.margin.left},0)`)
            .call(axes.y);
          [...Array(this.numberOfThetas).keys()].forEach(i => {
            gt.append("path")
              .datum(data)
              .attr("fill", "none")
              .attr("stroke", this.graph.analysis.colors[i%this.graph.analysis.colors.length])
              .attr("stroke-width", 5)
              .attr("stroke-linejoin", "round")
              .attr("stroke-linecap", "round")
              .attr("d", d3.line().x(d => scale.x(d.x)).y(d => scale.y(d.y[i])));
            // gt.selectAll()
            //   .data(data)
            //   .enter().append("circle")
            //   .attr("cx", d => scale.x(d.x))
            //   .attr("cy", d => scale.y(d.y[i]))
            //   .attr("r", 8)
            //   .attr("fill", this.graph.analysis.colors[i%this.graph.analysis.colors.length])
            //   .attr("stroke", "white")
            //   .attr("stroke-width", 0);
          });

          let thetanames = this.training.results.header.slice(startindex, startindex+this.numberOfThetas);
          [...Array(this.numberOfThetas).keys()].forEach(i => {
            gt.append("text")
              .attr("x", scale.x(data[data.length-1].x)+10)
              .attr("y", scale.y(data[data.length-1].y[i]))
              .attr("text-anchor", "start")
              .attr("dominant-baseline", "middle")
              .attr("stroke-width", 3.5)
              .attr("stroke", this.graph.analysis.colors[i%this.graph.analysis.colors.length])
              .text(thetanames[i]);
            gt.append("text")
              .attr("x", scale.x(data[data.length-1].x)+10)
              .attr("y", scale.y(data[data.length-1].y[i]))
              .attr("text-anchor", "start")
              .attr("dominant-baseline", "middle")  
              .style("fill", "white")
              .text(thetanames[i]);
          });
          gt.append("text")
            .attr("x", (scale.x.range()[1] + scale.x.range()[0])/2)
            .attr("y", this.graph.view_box[1] + this.graph.view_box[3] - 10)
            .attr("text-anchor", "middle")
            .attr("dominant-baseline", "text-bottom")
            .text("Iteration")
          let labelpos = {
            x: this.graph.view_box[0],
            y: (scale.y.range()[1] + scale.y.range()[0])/2
          }
          gt.append("text")
            .attr("x", labelpos.x)
            .attr("y", labelpos.y)
            .attr("transform", `rotate(-90,${labelpos.x},${labelpos.y})`)
            .attr("text-anchor", "middle")
            .attr("dominant-baseline", "middle")
            .text("Thetas, Θ");
        },
        drawErrorGraph: function () {
          let ge = d3.select("#g-error");
          ge.selectAll("*").remove();
          if (this.training.results.content.length == 0) { return; }

          let startindex = this.settings.parameters.neuron_n[0]+this.settings.parameters.neuron_n[this.settings.parameters.neuron_n.length-1]+this.numberOfWeights+this.numberOfThetas+this.numberOfThetas;
          let numberoferrors = this.settings.parameters.neuron_n[this.settings.parameters.neuron_n.length-1];

          let data = this.training.results.content.map((d,i) => ({
            x: i+1,
            y: d.slice(
              startindex,
              startindex + numberoferrors
            )
          }));
          let rmsedata = data.reduce((acc,d,i,arr) => {
            let sta = Math.floor(i/this.training.data.length) * this.training.data.length;
            acc.push({
              x: d.x,
              y: arr.slice(sta, sta+this.training.data.length).reduce((a,v) => { v.y.forEach((y,yi) => a[yi]=a[yi]+y*y); return a; }, d.y.map(() => 0)).map(sse => Math.sqrt(sse/this.training.data.length))
            });
            return acc;
          }, []);
          let scale = {
            x: d3.scaleLinear()
              .domain([Math.min(...data.map(d => d.x)), Math.max(...data.map(d => d.x))])
              .range([this.graph.margin.left, this.graph.view_box[2] + this.graph.view_box[0] - this.graph.margin.right]),
            y: d3.scaleLinear()
              .domain([Math.min(...data.reduce((acc,d) => { acc.push(...d.y); return acc; }, [])), Math.max(...data.reduce((acc,d) => { acc.push(...d.y); return acc; }, []))])
              .range([this.graph.view_box[3] + this.graph.view_box[1] - this.graph.margin.bottom, this.graph.view_box[1] + this.graph.margin.top]),
          };
          let xtickValues = scale.x.ticks().filter(Number.isInteger);
          let axes = {
            x: d3.axisBottom(scale.x).tickValues(xtickValues).tickFormat(d3.format('d')),
            y: d3.axisLeft(scale.y)
          };

          ge.append("g")
            .attr("transform", `translate(0,${this.graph.view_box[3]+this.graph.view_box[1]-this.graph.margin.bottom})`)
            .call(axes.x);
          ge.append("g")
            .attr("transform", `translate(${this.graph.view_box[0]+this.graph.margin.left},0)`)
            .call(axes.y);
          [...Array(numberoferrors).keys()].forEach(i => {
            ge.append("path")
              .datum(data)
              .attr("fill", "none")
              .attr("stroke", this.graph.analysis.colors[(i*2)%this.graph.analysis.colors.length])
              .attr("stroke-width", 5)
              .attr("stroke-linejoin", "round")
              .attr("stroke-linecap", "round")
              .attr("d", d3.line().x(d => scale.x(d.x)).y(d => scale.y(d.y[i])));
            ge.append("path")
              .datum(rmsedata)
              .attr("fill", "none")
              .attr("stroke", this.graph.analysis.colors[(i*2+1)%this.graph.analysis.colors.length])
              .attr("stroke-width", 5)
              .attr("stroke-linejoin", "round")
              .attr("stroke-linecap", "round")
              .attr("d", d3.line().x(d => scale.x(d.x)).y(d => scale.y(d.y[i])));
            // ge.selectAll()
            //   .data(data)
            //   .enter().append("circle")
            //   .attr("cx", d => scale.x(d.x))
            //   .attr("cy", d => scale.y(d.y[i]))
            //   .attr("r", 8)
            //   .attr("fill", this.graph.analysis.colors[i%this.graph.analysis.colors.length])
            //   .attr("stroke", "white")
            //   .attr("stroke-width", 0);
          });

          let errornames = this.training.results.header.slice(startindex, startindex+numberoferrors);
          [...Array(numberoferrors).keys()].forEach(i => {
            ge.append("text")
              .attr("x", scale.x(data[data.length-1].x)+10)
              .attr("y", scale.y(data[data.length-1].y[i]))
              .attr("text-anchor", "start")
              .attr("dominant-baseline", "middle")
              .attr("stroke-width", 3.5)
              .attr("stroke", this.graph.analysis.colors[(i*2)%this.graph.analysis.colors.length])
              .text(errornames[i]);
            ge.append("text")
              .attr("x", scale.x(data[data.length-1].x)+10)
              .attr("y", scale.y(data[data.length-1].y[i]))
              .attr("text-anchor", "start")
              .attr("dominant-baseline", "middle")  
              .style("fill", "white")
              .text(errornames[i]);
            ge.append("text")
              .attr("x", scale.x(rmsedata[rmsedata.length-1].x)+10)
              .attr("y", scale.y(rmsedata[rmsedata.length-1].y[i]))
              .attr("text-anchor", "start")
              .attr("dominant-baseline", "middle")
              .attr("stroke-width", 3.5)
              .attr("stroke", this.graph.analysis.colors[(i*2+1)%this.graph.analysis.colors.length])
              .text(`rms ${errornames[i]}`);
            ge.append("text")
              .attr("x", scale.x(rmsedata[rmsedata.length-1].x)+10)
              .attr("y", scale.y(rmsedata[rmsedata.length-1].y[i]))
              .attr("text-anchor", "start")
              .attr("dominant-baseline", "middle")  
              .style("fill", "white")
              .text(`rms ${errornames[i]}`);
          });
          ge.append("text")
            .attr("x", (scale.x.range()[1] + scale.x.range()[0])/2)
            .attr("y", this.graph.view_box[1] + this.graph.view_box[3] - 10)
            .attr("text-anchor", "middle")
            .attr("dominant-baseline", "text-bottom")
            .text("Iteration")
          let labelpos = {
            x: this.graph.view_box[0],
            y: (scale.y.range()[1] + scale.y.range()[0])/2
          }
          ge.append("text")
            .attr("x", labelpos.x)
            .attr("y", labelpos.y)
            .attr("transform", `rotate(-90,${labelpos.x},${labelpos.y})`)
            .attr("text-anchor", "middle")
            .attr("dominant-baseline", "middle")
            .text("Errors");
        },
        drawDecisionRegionsGraph: function () {
          let gdr = d3.select("#g-decision-regions");
          gdr.selectAll("*").remove();
          let showing_iter = Math.min((this.display.epoch - 1) * this.training.data.length + this.display.point, this.training.results.content.length - 1);
          if (showing_iter < 0) { return; }
          
          let startindex = this.settings.parameters.neuron_n[0] + this.settings.parameters.neuron_n[this.settings.parameters.neuron_n.length-1];
          let weights = this.training.results.content[showing_iter].slice(startindex,startindex+this.numberOfWeights);
          weights = this.settings.parameters.neuron_n.slice(1).reduce((acc,n,i) => {
            let layer = [];
            [...Array(n)].forEach(() => {
              let neuron = [];
              [...Array(this.settings.parameters.neuron_n[i])].forEach(() => {
                neuron.push(weights.shift());
              });
              layer.push(neuron);
            });
            acc.push(layer);
            return acc;
          }, []);
          let thetas = this.training.results.content[showing_iter].slice(startindex+this.numberOfWeights,startindex+this.numberOfWeights+this.numberOfThetas);
          thetas = this.settings.parameters.neuron_n.slice(1).reduce((acc,n) => {
            let layer = [];
            [...Array(n)].forEach(() => {
              layer.push(thetas.shift());
            });
            acc.push(layer);
            return acc;
          }, []);

          let step = {
            x: (this.graph.decision_regions.x.max - this.graph.decision_regions.x.min)/(this.graph.decision_regions.x.count-1),
            y: (this.graph.decision_regions.y.max - this.graph.decision_regions.y.min)/(this.graph.decision_regions.y.count-1)
          };
          let domain = {
            x: [...Array(this.graph.decision_regions.x.count).keys()].map(i => this.graph.decision_regions.x.min + i*step.x),
            y: [...Array(this.graph.decision_regions.y.count).keys()].map(i => this.graph.decision_regions.y.min + i*step.y),
            color: [...Array(11).keys()].map(i => i*0.1)
          };
          let scale = {
            xBand: d3.scaleBand()
                .domain(domain.x)
                .range([this.graph.decision_regions.view_box[0]+this.graph.decision_regions.margin.left, this.graph.decision_regions.view_box[0]+this.graph.decision_regions.view_box[2]-this.graph.decision_regions.margin.right]),
            yBand: d3.scaleBand()
                .domain(domain.y)
                .range([this.graph.decision_regions.view_box[1]+this.graph.decision_regions.view_box[3]-this.graph.decision_regions.margin.bottom, this.graph.decision_regions.view_box[1]+this.graph.decision_regions.margin.top]),
            color: d3.scaleLinear()
                .domain([domain.color[0], domain.color[domain.color.length-1]])
                .range([vm.$vuetify.theme.themes.light.secondary, vm.$vuetify.theme.themes.light.primary])
          }
          scale.x = d3.scaleLinear()
            .domain([domain.x[0], domain.x[domain.x.length-1]])
            .range([scale.xBand(domain.x[0]), scale.xBand(domain.x[domain.x.length-1])].map(x => x + .5*scale.xBand.bandwidth()));
          scale.y = d3.scaleLinear()
            .domain([domain.y[0], domain.y[domain.y.length-1]])
            .range([scale.yBand(domain.y[0]), scale.yBand(domain.y[domain.y.length-1])].map(y => y + .5*scale.yBand.bandwidth()));
          scale.colorbar = d3.scaleBand()
            .domain(domain.color)
            .range(scale.yBand.range());
          let tickValues = {
            x: scale.x.ticks().filter(Number.isInteger),
            y: scale.y.ticks().filter(Number.isInteger),
            colorbar: [...domain.color]
          };
          let axes = {
            x: d3.axisBottom(scale.x).tickValues(tickValues.x).tickFormat(d3.format('d')),
            y: d3.axisLeft(scale.y).tickValues(tickValues.y).tickFormat(d3.format('d')),
            colorbar: d3.axisRight(scale.colorbar).tickValues(tickValues.colorbar).tickFormat(d3.format('.1f')),
          };

          gdr.append("g")
            .attr("transform", `translate(0,${this.graph.decision_regions.view_box[3]+this.graph.decision_regions.view_box[1]-this.graph.decision_regions.margin.bottom})`)
            .call(axes.x);
          gdr.append("g")
            .attr("transform", `translate(${this.graph.decision_regions.view_box[0]+this.graph.decision_regions.margin.left},0)`)
            .call(axes.y);
          gdr.append("g")
            .attr("transform", `translate(${scale.xBand.range()[1] + 2*scale.xBand.bandwidth()},0)`)
            .call(axes.colorbar);
          gdr.selectAll()
            .data(domain.x.reduce((acc,xval) => {
              acc.push(...domain.y.map(yval => ({x: xval, y:yval, c:this.calcOutput([xval,yval], weights, thetas, this.settings.parameters.activation_fcns)})));
              return acc;
            }, []))
            .enter()
            .append("rect")
            .attr("x", d => scale.xBand(d.x))
            .attr("y", d => scale.yBand(d.y))
            .attr("width", d => scale.xBand.bandwidth())
            .attr("height", d => scale.yBand.bandwidth())
            .attr("fill", d => scale.color(d.c[d.c.length-1][0]))
            .on("mousemove", (event,d) => {
              d3.select("#gdrtt")
                .style("opacity", 0.9)
                .style("left", `${event.pageX+20}px`)
                .style("top", `${event.pageY}px`)
                .html(`x<sub>1</sub>: ${d.x.toFixed(2)}<br>x<sub>2</sub>: ${d.y.toFixed(2)}<br>y: ${d.c[d.c.length-1][0].toFixed(2)}`);
              gdr.append("rect")
                .attr("id", "highlight-cell")
                .attr("x", event.target.x.baseVal.valueAsString)
                .attr("y", event.target.y.baseVal.valueAsString)
                .attr("width", event.target.width.baseVal.valueAsString)
                .attr("height", event.target.height.baseVal.valueAsString)
                .attr("fill", "none")
                .attr("stroke", this.$vuetify.theme.themes.light.highlight)
                .attr("stroke-width",3);
            })
            .on("mouseleave", (event,d) => {
              d3.select("#gdrtt")
                .style("opacity",0)
                .style("left", "0px")
                .style("top", "0px");
              gdr.selectAll("#highlight-cell").remove();
            });
          gdr.selectAll("circle")
            .data(this.training.data.map(d => ({x: d[0], y: d[1], o: d[2]})))
            .enter().append("circle")
            .attr("cx", d => scale.x(d.x))
            .attr("cy", d => scale.y(d.y))
            .attr("r", 15)
            .attr("fill", d => scale.color(d.o))
            .attr("stroke", "white")
            .attr("stroke-width", 3)
            .on("mousemove", (event,d) => {
              d3.select("#gdrtt")
                .style("opacity", 0.9)
                .style("left", `${event.pageX+20}px`)
                .style("top", `${event.pageY}px`)
                .html(`x<sub>1</sub>: ${d.x.toFixed(2)}<br>x<sub>2</sub>: ${d.y.toFixed(2)}<br>y: ${d.o.toFixed(2)}`);
              d3.select(event.target)
                .attr("stroke", this.$vuetify.theme.themes.light.highlight);
            })
            .on("mouseleave", () => {
              d3.select("#gdrtt")
                .style("opacity",0)
                .style("left", "0px")
                .style("top", "0px");
              d3.select(event.target)
                .attr("stroke", "white");
            });
          gdr.append("text")
            .attr("x", (scale.x.range()[1] + scale.x.range()[0])/2)
            .attr("y", this.graph.decision_regions.view_box[1] + this.graph.decision_regions.view_box[3] - 10)
            .attr("text-anchor", "middle")
            .attr("dominant-baseline", "text-bottom")
            .text("x1")
          let labelpos = {
            x: this.graph.decision_regions.view_box[0],
            y: (scale.y.range()[1] + scale.y.range()[0])/2
          }
          gdr.append("text")
            .attr("x", labelpos.x)
            .attr("y", labelpos.y)
            .attr("transform", `rotate(-90,${labelpos.x},${labelpos.y})`)
            .attr("text-anchor", "middle")
            .attr("dominant-baseline", "middle")
            .text("x2")

          gdr.selectAll()
            .data(scale.colorbar.domain())
            .enter()
            .append("rect")
            .attr("x", scale.xBand.range()[1] + 1*scale.xBand.bandwidth())
            .attr("y", d => scale.colorbar(d))
            .attr("width", scale.xBand.bandwidth())
            .attr("height", scale.colorbar.bandwidth())
            .attr("fill", d => scale.color(d));;
        }
      }
    })
  </script>
</body>
</html>
